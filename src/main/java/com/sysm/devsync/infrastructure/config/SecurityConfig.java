package com.sysm.devsync.infrastructure.config;

import com.nimbusds.jose.shaded.gson.internal.LinkedTreeMap;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.core.convert.converter.Converter;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.annotation.web.configurers.HeadersConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtClaimNames;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;
import org.springframework.security.web.SecurityFilterChain;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/*
    @EnableWebSecurity
    Purpose: This annotation is used to enable Spring Security’s web security support and provide the Spring MVC integration.

    Function: It activates the Spring Security filter chain and configuration, allowing you to customize security settings
              for web applications. Using @EnableWebSecurity allows you to customize security policies, such as which URLs
              require authentication, how to handle form login, etc.

    @EnableMethodSecurity(securedEnabled = true, jsr250Enabled = true)
    Purpose: This annotation enables Spring Security’s method-level security capabilities. It allows you to use annotations
             to secure individual methods in your Spring beans.

    Function: By enabling method security, you can use annotations like @Secured, @RolesAllowed, and @PreAuthorize to define
              security constraints on methods.
              Ex: @PreAuthorize("hasRole('ROLE_USER')"), @RolesAllowed("ROLE_USER"), @Secured("ROLE_ADMIN")

 */

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(securedEnabled = true, jsr250Enabled = true) // CRITICAL: Enables @PreAuthorize
public class SecurityConfig {

    private static final Logger logger = LoggerFactory.getLogger(SecurityConfig.class);
    private static final String ROLE_ADMIN = "ADMIN";
    private static final String ROLE_DEFAULT = "READER";
    private static final String[] AUTH_WHITELIST = {
            "/actuator/**",
    };

    @Bean
    public SecurityFilterChain securityFilterChain(final HttpSecurity http) throws Exception {
        logger.info("SecurityFilterChain");
        return http
                //Cross Site Request Forgery. Spring check if all post-methods contain the parameter
                //a random ID, generated by its self (spring) and returned.
                //This is for stateful security layer. In MS the frontend is separated
                //Forgery is when a third person makes a post from another site using the cookie authorization
                //from another person and makes a request in their name
                .csrf(AbstractHttpConfigurer::disable)

                //Authorize the requests, paths which need to be authorized
                .authorizeHttpRequests(authorize -> authorize
                        .requestMatchers(AUTH_WHITELIST).permitAll()
                        .anyRequest().authenticated()) // .hasRole(ROLE_ADMIN)

                //Classes to convert the default keycloak JWT to spring JWT format
                .oauth2ResourceServer(oauth2 -> oauth2
                        .bearerTokenResolver(new CustomBearerTokenResolver())
                        .jwt(jwt -> jwt.jwtAuthenticationConverter(new KeycloakJwtConverter())))

                //Session is stateless
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                //Cookie received needs to be from the same origen. The same host where it was created for be used
                .headers(headers -> headers.frameOptions(HeadersConfigurer.FrameOptionsConfig::sameOrigin))
                .build();
    }

    /**
     * Bellow statics classes to convert the Keycloak JWT format to Spring JWT format.
     */

    @SuppressWarnings("NullableProblems")
    static class KeycloakJwtConverter implements Converter<Jwt, AbstractAuthenticationToken> {
        /* Class, to convert the Keycloak JWT format to Spring JWT format.
              Keycloak JWTs have a specific structure that includes realm roles and client roles.
              This converter extracts those roles and converts them into Spring's GrantedAuthority format.
              It also extracts the principal (user ID) from the JWT.
         */

        private final KeycloakAuthoritiesConverter authoritiesConverter;

        public KeycloakJwtConverter() {
            logger.info("KeycloakJwtConverter");
            this.authoritiesConverter = new KeycloakAuthoritiesConverter();
        }

        @Override
        public AbstractAuthenticationToken convert(final Jwt jwt) {
            logger.info("KeycloakJwtConverter: convert");
            return new JwtAuthenticationToken(jwt, extractAuthorities(jwt), extractPrincipal(jwt));
        }

        private String extractPrincipal(final Jwt jwt) {
            logger.info("KeycloakJwtConverter: extractPrincipal");
            return jwt.getClaimAsString(JwtClaimNames.SUB);
        }

        private Collection<? extends GrantedAuthority> extractAuthorities(final Jwt jwt) {
            logger.info("KeycloakJwtConverter: extractAuthorities");
            return this.authoritiesConverter.convert(jwt);
        }
    }

    @SuppressWarnings({"NullableProblems", "unchecked"})
    static class KeycloakAuthoritiesConverter implements Converter<Jwt, Collection<GrantedAuthority>> {

        /* Class, to convert the Keycloak authorities format to Spring authorities format.
              Keycloak JWTs include roles in the "realm_access" and "resource_access" claims.
              This converter extracts those roles and converts them into Spring's GrantedAuthority format.
              It prefixes each role with "ROLE_" to comply with Spring Security's conventions.
         */

        private static final String REALM_ACCESS = "realm_access";
        private static final String ROLES = "roles";
        private static final String RESOURCE_ACCESS = "resource_access";
        private static final String SEPARATOR = "_";
        private static final String ROLE_PREFIX = "ROLE_";

        @Override
        public Collection<GrantedAuthority> convert(final Jwt jwt) {
            logger.info("KeycloakAuthoritiesConverter: convert");
            final var realmRoles = extractRealmRoles(jwt);
            final var resourceRoles = extractResourceRoles(jwt);

            return Stream.concat(realmRoles, resourceRoles)
                    .map(role -> new SimpleGrantedAuthority(ROLE_PREFIX + role.toUpperCase()))
                    .collect(Collectors.toSet());
        }

        private Stream<String> extractResourceRoles(final Jwt jwt) {
            logger.debug("KeycloakAuthoritiesConverter: extractResourceRoles");
            /* Extract the client roles, below is an example of the resource_access claim
                {
                    "resource_access": {
                        "project-service": {
                            "roles": [
                                "admin",
                                "user"
                            ]
                        }
                    }
             */

            Map<String, Object> resourceAccess = jwt.getClaimAsMap(RESOURCE_ACCESS);
            if (resourceAccess == null || resourceAccess.isEmpty()) {
                return Stream.empty();
            }

            return resourceAccess.entrySet().stream()
                    .filter(entry -> entry.getValue() instanceof Map)
                    .flatMap(entry -> {
                        final String resourceName = entry.getKey();
                        final Map<String, Object> details = (Map<String, Object>) entry.getValue();
                        final Object rolesClaim = details.get(ROLES);

                        if (rolesClaim instanceof Collection) {
                            Collection<String> roles = (Collection<String>) rolesClaim;
                            return roles.stream().map(role -> resourceName.concat(SEPARATOR).concat(role));
                        }
                        return Stream.empty();
                    });

//            return resourceAccess.entrySet().stream()
//                    .flatMap(entry -> {
//                        String resourceName = entry.getKey();
//                        // Safely check and cast the value
//                        if (entry.getValue() instanceof Map) {
//                            @SuppressWarnings("unchecked")
//                            Map<String, Object> resourceDetails = (Map<String, Object>) entry.getValue();
//
//                            Object rolesClaim = resourceDetails.get(ROLES);
//                            if (rolesClaim instanceof Collection) {
//                                @SuppressWarnings("unchecked")
//                                Collection<String> roles = (Collection<String>) rolesClaim;
//                                return roles.stream().map(role -> resourceName.concat(SEPARATOR).concat(role));
//                            }
//                        }
//                        return Stream.empty();
//                    });
        }

        private Stream<String> extractRealmRoles(final Jwt jwt) {
            logger.debug("KeycloakAuthoritiesConverter: extractRealmRoles");
            /* Extract the realm roles, below is an example of the realm_access claim
                {
                    "realm_access": {
                        "roles": [
                            "admin",
                            "user"
                        ]
                    }
                }
             */

            return Optional.ofNullable(jwt.getClaimAsMap(REALM_ACCESS))
                    .map(resource -> (Collection<String>) resource.get(ROLES))
                    .orElse(Collections.emptyList())
                    .stream();
        }
    }

    static class CustomBearerTokenResolver implements BearerTokenResolver {
        /* Class, to resolve the Bearer token from the Authorization header, basic extract the token from the header.
              This is useful when the default Bearer token resolver does not meet specific requirements or when you
              want to customize the way tokens are extracted from requests.
         */

        @Override
        public String resolve(HttpServletRequest request) {
            logger.debug("CustomBearerTokenResolver: resolve");
            // Retrieve the Authorization header from the request
            String authorizationHeader = request.getHeader("Authorization");

            // Check if the Authorization header is present and starts with "Bearer"
            if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
                // Extract the token part (remove the "Bearer" prefix)
                return authorizationHeader.substring(7);
            }

            return null;
        }
    }
}
